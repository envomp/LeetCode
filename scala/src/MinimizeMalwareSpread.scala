import scala.collection.mutable

object MinimizeMalwareSpread {

	def DFS(graph: mutable.HashMap[Int, Array[Int]], visited: mutable.HashSet[Int], node: Int): mutable.HashSet[Int] = {
		visited.add(node)
		graph(node).foreach(x => {
			if (!visited.contains(x)) {
				DFS(graph, visited, x)
			}
		})
		visited
	}

	def minMalwareSpread(_graph: Array[Array[Int]], _initial: Array[Int]): Int = {
		val initial = _initial.sorted
		var answer = 0
		var minimum = Int.MaxValue

		val graph: mutable.HashMap[Int, Array[Int]] = new mutable.HashMap()
		_graph.indices.foreach(i => {
			val arr = _graph(i)
			graph(i) = arr.indices.map(x => arr(x) * (x + 1)).filter(x => x != 0).map(x => x - 1).toArray
		})

		val sub_problems: mutable.HashMap[Int, mutable.HashSet[Int]] = new mutable.HashMap()

		for (to_remove <- initial) {
			val infected_case: mutable.HashSet[Int] = new mutable.HashSet()
			for (other <- initial) {
				if (other != to_remove) {
					if (sub_problems.contains(other)) {
						infected_case.addAll(sub_problems(other))
					} else {
						val sub_problem = DFS(graph, new mutable.HashSet(), other)
						sub_problems(other) = sub_problem
						infected_case.addAll(sub_problem)
					}
				}
			}

			if (infected_case.size < minimum) {
				minimum = infected_case.size
				answer = to_remove
			}
		}

		answer
	}

	def main(args: Array[String]): Unit = {
		println(minMalwareSpread(Array(Array(1, 1, 0), Array(1, 1, 0), Array(0, 0, 1)), Array(0, 1, 2)))
	}
}
